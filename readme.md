### 默认情况下，TS 会做出下面几种假设：

1.假设当前的执行环境是 dom  
2.如果代码中没有使用模块化语句（import，export），便认为该代码是全局执行  
3.编译的目标代码是 ES3

### 有两种方式改变以上假设

1.使用 tsc 命令时，添加参数  
2.使用 tsconfig.json 配置文件

### 配置文件

1.使用了配置文件后，使用 tsc 命令进行编译时，不能跟上文件名了，因为这样会忽略配置文件

### @types

@types 是一个 ts 官方的类型库，其中包含了很多对 js 代码的类型描述，默认配置文件 lib 会安装默认的执行环境，如果自定义 lib 下没有相应配置，则某些语句会报错，可以通过另外安装 @types/xxx 来提供类型定义

> JQuery: 用 js 写的，没有类型检查  
> 安装@type/jquery, 为 jq 库添加类型检查

@types/node: 为 node 环境的提供类型检查，例如 lib:['es2016'] 下，console 不会报错

### 使用第三方库简化编译流程

ts-node: ts 代码直接在内存中完成编译，并同时完成运行  
nodemon: 监测文件的变化

### 基本类型约束

> TS 是一个可选的静态的类型系统！！！

### 如何进行类型约束

仅需要在变量，函数的参数，函数的返回值位置加上`:类型`  
ts 在很多场景中可以完成类型推导，自动推导  
any: 表示任意类型，ts 对此类型不做类型检查

> 如何区别数字字符串和数字，关键看怎么读？  
> 如果按照数字的方式朗读，则为数字；否则为字符串  
> 所以手机号，身份证这一类应该是字符串

### 源代码和编译结果的差异

编译结果中没有类型约束信息，ts 是静态的，在编译中生效

### 基本类型

- number: 数字
- string: 字符串
- boolean: 布尔值
- array: 数组
- object: 对象
- null & undefined

null 和 undefined 是其他所有类型的子类型，它们可以赋值给其他类型；因为类型推导上没有错误，所以使用上会造成不必要的麻烦，因此，通过添加`strictNullChecks:true`, 可以获得更加严格的空类型检查，null 和 undefined 只能赋值给自身。

### 基本类型-其他类型

- 联合类型: 多种类型选其一  
  配合类型保护进行判断  
  类型保护：当对某个变量进行类型判断后，在判断语句块中便可确定它的确切类型，typeof 可以触发基本类型保护
- void 类型：通常用于约束函数的返回值，表示该函数没有任何返回
- never 类型: 通常用于约束函数的返回值，表示该函数永远不可能结束
- 字面量类型：表示使用一个值进行约束
- 元祖类型（Tuple）: 表示一个固定长度的数组，并且数组每一个项的类型也确定
- any 类型: 可以绕过类型检查，因此，any 类型的数据可以赋值给任意类型

### 拓展类型-类型别名

对已知的一些类型定义名称，便于灵活使用

```
type 类型名称 = ...
```

### 函数的相关约束

函数重载：在函数实现之前，对函数调用的多重情况进行声明  
可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递，可选参数必须在参数列表的末尾

### 拓展类型-枚举

> 拓展类型：类型别名、枚举、接口、类

枚举：通常用于约束某个变量的取值范围，看下面  
字面量和联合类型配合使用，也可以达到同样的效果  
为什么出现，解决了什么问题

#### 字面量类型的问题

- 在类型约束位置，会产生重复代码，可以使用类型别名解决问题
- 逻辑含义和真实值产生了混淆， 会导致修改当前真实值的时候，产生大量的修改
- 字面量类型不会进入编译结果

这时候，枚举就派上用场了

#### 枚举

参与编译结果
如何定义一个枚举类型：

```
enum 枚举名{
  枚举字段1 = 值1,
  枚举字段2 = 值2,
}
```

枚举会出现在编译结果中，表现为对象  
枚举的规则:

- 枚举字段的值可以是字符串或数字
- 数字枚举的值会自动自增
- 被数字枚举约束的变量，可以直接被赋值为数字
- 数字枚举的编译结果和字符串枚举有差异

最佳实践：

- 尽量不要在一个枚举中既出现字符串字段，又出现数字字段
- 使用枚举时，尽量使用枚举字段的名称，不要使用真实值

#### 数字枚举的位运算（位枚举）

### 接口和类型兼容性

### 拓展类型-接口

> 扩展类型：类型别名、枚举、接口、类

TypeScript 的接口: 用于约束类、对象、函数的契约（标准）  
契约（标准）的形式：

- API 文档，弱标准
- 代码约束，强标准

```
interface 接口名 ...
```

和类型别名一样，代码不会出现在编译结果中，与类型别名最大区别是接口可以约束类

1.接口约束对象  
2.接口约束函数

**接口可以继承**

```
class xxx extends xxx {

}
interface A extends B {}
```

可以通过接口之间的继承，实现多种接口的组合  
使用类目别名可以实现类似的效果，需要同意`&`，它叫做交叉类型  
它们的区别是：

- 子接口不能覆盖父接口的成员（不同类型）
- 交叉类型会把相同成员的类型进行交叉（新版已经不行了，会变成 never 类型）

**readonly**

只读修饰符, 也不在编译结果中

### 类型兼容性

B->A, 如果能完成赋值，则 A 和 B 类型兼容

鸭子辨型法（子结构辨型法）：目标类型需要某一些特征，赋值的类型只要能满足该特征即可（会嘎嘎叫会游泳就是鸭子）

- 基本类型：完全匹配
- 对象类型： 鸭子辨型法  
  类型断言  
  当直接使用对象字面量进行赋值的时候，会进行更严格的类型判断
- 函数类型：  
  一切无比自然（记性兼容，符合开发习惯，提供开发效率）  
  **参数**：可以传递给目标函数的参数可以少，但不可以多  
  **返回值**：要求返回，必须返回，不要求时随意
