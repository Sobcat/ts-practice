#### 默认情况下，TS 会做出下面几种假设：

1.假设当前的执行环境是 dom  
2.如果代码中没有使用模块化语句（import，export），便认为该代码是全局执行  
3.编译的目标代码是 ES3

#### 有两种方式改变以上假设

1.使用 tsc 命令时，添加参数  
2.使用 tsconfig.json 配置文件

#### 配置文件

1.使用了配置文件后，使用 tsc 命令进行编译时，不能跟上文件名了，因为这样会忽略配置文件

#### @types

@types 是一个 ts 官方的类型库，其中包含了很多对 js 代码的类型描述，默认配置文件 lib 会安装默认的执行环境，如果自定义 lib 下没有相应配置，则某些语句会报错，可以通过另外安装 @types/xxx 来提供类型定义

> JQuery: 用 js 写的，没有类型检查  
> 安装@type/jquery, 为 jq 库添加类型检查

@types/node: 为 node 环境的提供类型检查，例如 lib:['es2016'] 下，console 不会报错

#### 使用第三方库简化编译流程

ts-node: ts 代码直接在内存中完成编译，并同时完成运行  
nodemon: 监测文件的变化

#### 基本类型约束

> TS 是一个可选的静态的类型系统

#### 如何进行类型约束

仅需要在变量，函数的参数，函数的返回值位置加上`:类型`  
ts 在很多场景中可以完成类型推导，自动推导  
any: 表示任意类型，ts 对此类型不做类型检查

> 如何区别数字字符串和数字，关键看怎么读？  
> 如果按照数字的方式朗读，则为数字；否则为字符串  
> 所以手机号，身份证这一类应该是字符串

#### 源代码和编译结果的差异

编译结果中没有类型约束信息，ts 是静态的，在编译中生效

#### 基本类型

- number: 数字
- string: 字符串
- boolean: 布尔值
- array: 数组
- object: 对象
- null & undefined

null 和 undefined 是其他所有类型的子类型，它们可以赋值给其他类型；因为类型推导上没有错误，所以使用上会造成不必要的麻烦，因此，通过添加`strictNullChecks:true`, 可以获得更加严格的空类型检查，null 和 undefined 只能赋值给自身。
